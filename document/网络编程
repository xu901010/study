一、
	1.基本概念：
		Socket又称套接字，应用程序通过它向网络发出请求或者应答网络请求。
	2.套接字之间的连接过程分四个步骤：服务器监听、客户端请求服务器、服务器确认、客户端确认、进行通信
		1）服务器监听：处于等待连接的状态，实时监控网络状态
		2）客户端请求：通过地址和端口号向服务器套接字提出连接请求
		3）服务器端连接确认：当服务器监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器套接字的描述发给客户端。
		4）客户端连接确认：一旦客户端确认了描述，连接就建立好了。服务器端套接字继续处于监听状态，继续接收其它客户端套接字的连接请求
	3.普通的bio不支持太多的客户端同时连接，因为每一个请求都会创建一个新的线程处理。线程数量过多，服务器压力非常大。每个线程都是要占用服务器资源的。
	4.伪异步IO(JDK1.5之前没有出nio之前都是采用这种方式实现)：
		采用线程池和任务队列可以实现一种伪异步的IO通信框架。就是将客户端的socket封装成一个task任务(实现runnable接口的类)然后投递到线程池中去，配置相应的队列进行实现。
二、NIO（JDK1.5以后）
	1.jdk1.7后才开始有异步+非阻塞。之前的NIO1.0版本只有非阻塞没有异步。
	2.IO(BIO)和NIO的区别：其本质就是阻塞和非阻塞的区别。
		1）阻塞概念：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么程序就一直等着，直到传输完毕为止。 inputStream、 outputStream
		2）非阻塞概念：应用程度直接可以获取已经准备就绪好的数据，无需等待。
	    3）BIO同步阻塞，NIO为同步非阻塞。inputStream以及outputStream都属于BIO。NIO并没有实现异步。在JDK1.7以后，升级了NIO库包，支持异步非阻塞通信模型即NIO2.0(AIO)
	    4）同步和异步：同步和异步一般是面向操作系统与应用程序对IO操作的层面上来区别的。同步时，应用程序会直接参与IO读写操作，并且我们的应用程序会直接阻塞到某一个方法上，直到数据准备就绪;或者采用轮询的策略实时检查数据的就绪状态，如果就绪则获取数据。异步时，则所有的IO读写操作交给操作系统处理，与我们的应用程序没有直接关系，我们程序不需要关心IO读写，当操作系统完成了IO读写操作时，会给我们应用程序发送通知，我们的应用程序直接拿走数据即可。
	3.几个概念：Buffer(缓冲区)、Channel(管道、通道)、Selector(选择器、多路复用器)
		1）Buffer是一个对象，它包含一些要写入或者要读取的数据。在NIO类库中加入Buffer对象，体现了新库与原IO的一个重要区别。在面向流的IO中，可以将数据直接写入或者读取到Stream对象中。在NIO库中，所有数据都是用缓冲区处理的(读写)。缓冲区实质上是一个数组，通常它是一个字节数组(ByteBuffer)，也可以用其他类型的数组。这个数组为缓冲区提供了数据的访问读写等操作属性。如位置、容量、上限等概念，参考api文档。Buffer类型：我们最常用的就是ByteBuffer，实际上每一种java基本类型都对于了一种缓冲区(除了Boolean类型_) ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer
	4.Channel
		网络数据通过Channel读取和写入，通道与流不同之处在于通道是双向的，而流只是一个方向上移动(一个流必须是InputStream或者OutputStream的子类)，而通道可以用于读、写或者二者同时进行，最关键的是可以与多路复用器结合，有多种的状态位，方便多路复用器去识别。通道分为两大类，一类是网络读写的(SelectableChannel)，一类是用于文件操作(FileChannel)，我们使用SocketChannel和ServerSockerChannel都是SelectableChannel的子类。 
	5.多路复用器(Selector)，
		1）它是NIO编程的基础，多路复用器提供选择已经就绪的任务的能力。简单说就是Selector会不断地轮询注册在其上的通道，如果某个通道发生了读写操作，这个通道就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以取得就绪的Channel集合，从而进行后续的IO操作。一个多路复用器可以负责成千上万Channel通道，没有上限，这也是JDK使用了epoll代替了传统的select实现，获取连接句柄没有限制。这也就意味着我们只要一个线程负责Selector的轮询，就可以接入成千上万个客户端，这也是JDK NIO库的巨大进步。
		2）它就类似一个管理者，管理了成千上万个管道，然后轮询那个管道的数据已经准备好，通知CPU执行IO的读取或写入操作。
		3）当IO事件(管道)注册到选择器以后，selector会分配给每个管道一个key值，相当于标签。selector选择器是以轮询的方式进行查找注册的所有IO事件(管道)，当我们的IO事件(管道)准备就绪后，select就会识别，会通过key值来找到相应的管道，进行相关的数据处理操作(从管道里读或写数据，写到我们的数据缓冲区中)。
		4）每个管道都会对选择器进行注册不同的事件状态，以使选择器查找：SelectionKey.OP_CONNECT、SelectionKey.OP_ACCEPT、SelectionKey.OP_READ、SelectionKey.OP_WRITE

	4.NIO的本质就是避免原始的TCP建立连接使用3次握手的操作，减少连接的开销。
	5.Selector多路复用器
		1）轮询所有注册的通道，根据通道状态，执行相关操作。 通道状态包括连接状态、阻塞状态、可读状态、可写状态

三、AIO
四、Netty
	1.TCP粘包、拆包问题解决方案
		1）消息定长，例如每个报文的大小固定为200个字节，如果不够，空位补空格
		2）在包尾部增加特殊字符进行分割，例如加回车等
		3）将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理
	2.Netty编解码技术
		1）说白了就是JAVA序列化技术，序列化目的就两个，第一进行网络传输，第二对象持久化
		2）java进行对象序列化的硬伤太多，比如java序列化没法跨语言、序列化后码流太大、序列化性能太低等等
		3）主流的编解码框架：JBOSS的Marshalling包、google的Protobuf、基于Protobuf的Kyro、MessagePack框架
	3.数据通信
		1）使用长连接通道不断开的形式进行通信，也就是服务器和客户端的通道一直处于开启状态，如果服务器性能足够好，并且我们客户端数量也比较少的情况下，推荐这种方式。
		2）一次性批量提交数据，采用短连接方式，也就是我们会把数据保存在本地临时缓冲区或者临时表里，当达到临界值时进行一次性批量提交，又或者根据定时轮询提交，这种情况弊端是做不到实时性传输，在对实时性不高的应用程序中可以推荐使用。
		3）我们可以使用一种特殊的长连接，在指定某一个时间之内，服务器与某台客户端没有任何通信，则断开连接。下次连接则是客户端向服务器发送请求的时候，再交建立连接。但是这种模式我们需要考虑2个因素：第一是如何在超时(即服务器与客户端没有任何通信)后关闭通道？关闭通道后我们又如何建立连接？第二是客户端宕机时，我们无需考虑，下次客户端重启之后我们就可以与服务器建立连接，但是服务器宕机时，我们的客户端如何与服务器进行连接呢？
	4.心跳检测
		1.我们使用Socket通信一般经常会处理多个服务器之间的心跳检测，一般来讲我们去维护服务器集群，肯定要有一台或几台服务器主机，然后还应该有N台(Slave),那么我们的主机肯定要时时刻刻知道自己下面的从服务器的各方面情况，然后进行实时监控的功能，这个在分布式架构里叫做心跳检测或者心跳监控。最佳处理方案使用一些通信框架进行实现，我们的netty就是可以做这样的一件事